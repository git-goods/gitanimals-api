package org.gitanimals.identity.domain

import io.kotest.assertions.throwables.shouldNotThrowAny
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.equals.shouldBeEqual
import org.junit.jupiter.api.DisplayName
import org.springframework.boot.autoconfigure.domain.EntityScan
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest
import org.springframework.data.jpa.repository.config.EnableJpaRepositories
import org.springframework.test.context.ContextConfiguration
import org.springframework.test.context.TestPropertySource

@DataJpaTest
@ContextConfiguration(classes = [UserService::class])
@DisplayName("UserService 클래스의")
@TestPropertySource("classpath:test.properties")
@EntityScan(basePackages = ["org.gitanimals.identity.domain"])
@EnableJpaRepositories(basePackages = ["org.gitanimals.identity.domain"])
internal class UserServiceTest(
    private val userService: UserService,
    private val userRepository: UserRepository,
) : DescribeSpec({

    afterEach {
        userRepository.deleteAll()
    }

    describe("givePoint 메소드는") {
        context("username에 해당하는 user가 존재할경우,") {
            val point = 100L
            userRepository.save(defaultUser)

            it("입력받은 point를 지급한다.") {
                userService.givePoint(USER_NAME, point, "FOR_TEST")

                val user = userRepository.findByName(USER_NAME)!!

                user.getPoints() shouldBeEqual point
            }
        }

        context("username에 해당하는 user가 존재하지 않을경우,") {
            it("아무런 동작도 하지 않는다") {
                shouldNotThrowAny {
                    userService.givePoint(NOT_EXIST_USER_NAME, 100, "FOR_TEST")
                }
            }
        }
    }

    describe("newUser 메소드는") {
        context("username과 년별 contribution 내역을 받으면,") {
            val username = "NEW_USER"
            val contributionPerYears = mapOf(2024 to 100, 2023 to 100)
            val expectedPoint = 200 * 100L

            it("contribution * 100의 포인트를 갖고있는 새로운 user를 생성한다.") {
                val user =
                    userService.newUser(username, DEFAULT_PROFILE_IMAGE, contributionPerYears)

                user.getPoints() shouldBeEqual expectedPoint
            }
        }
    }
}) {

    private companion object {
        private const val NOT_EXIST_USER_NAME = "NOT_EXIST"
        private const val USER_NAME = "NAME"
        private const val DEFAULT_PROFILE_IMAGE = "profile_imge"
        private val defaultUser = user(name = USER_NAME)
    }
}
